{"version":3,"file":"182.js","mappings":"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","sources":["webpack://mkv-web/webpack/universalModuleDefinition","webpack://mkv-web/webpack/bootstrap","webpack://mkv-web/webpack/runtime/publicPath","webpack://mkv-web/./src/worker/ffmpeg.ts","webpack://mkv-web/./node_modules/comlink/dist/esm/comlink.mjs","webpack://mkv-web/./src/worker/chunked-remuxer-worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.p = \"/includes/\";","/// <reference path=\"./index.d.ts\" />\nimport FFMpegCore from './ffmpeg-core/ffmpeg-core.js';\nimport FFMpegWasm from './ffmpeg-core/ffmpeg-core.wasm';\nimport FFMpegWorker from './ffmpeg-core/ffmpeg-core.js';\nimport * as path from 'path-browserify';\nimport { Observable, fromEventPattern, firstValueFrom } from 'rxjs';\nimport { takeWhile, toArray } from 'rxjs/operators';\n\nself.importScripts(\n  FFMpegCore\n);\n\nenum FFmpegState {\n  Uninitialized = 1,\n  Initializing,\n  Idle,\n  Busy\n}\n\ninterface Stream {\n  id: string\n  lang?: string\n  /** Long format description of a stream e.g. 'h264 (High 10), yuv420p10le(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], 23.98 fps, 23.98 tbr, 1k tbn, 47.95 tbc (default)' **/\n  formatDescription?: string\n}\n\nexport interface MediaMetadata {\n  durationSeconds: number\n  audioStreams: Stream[]\n  videoStreams: Stream[]\n  subtitleTracks: Stream[]\n  attachments: Stream[]\n}\n\ninterface ContainerType {\n  /** FFMpeg format code of container as listed by 'ffmpeg -formats' **/\n  ffmpegFormat: string\n  /** MIME type of container for SourceBuffer of a MediaSource  **/\n  mime: string\n}\n\nexport interface RemuxedChunkStream {\n  data: Uint8Array\n  mime: string\n}\n\nexport interface RemuxedChunk {\n  videoChunk: RemuxedChunkStream,\n  audioChunk: RemuxedChunkStream\n}\n\nfunction ffmpegFormatToCompatibleContainer(format: string): ContainerType {\n  if (format.startsWith(\"h264\")) {\n    return {\n      ffmpegFormat: \"mp4\",\n      mime: 'video/mp4; codecs=\"avc1.640033' // AVC High Level 5.1\n    };\n  } else if (format.startsWith(\"flac\")) {\n    return {\n      ffmpegFormat: \"mp4\",\n      mime: 'audio/mp4; codecs=\"flac\"'\n    };\n  } else if (format.startsWith(\"mp3\")) {\n    return {\n      ffmpegFormat: \"mp4\",\n      mime: 'audio/mp4; codecs=\"mp3\"'\n    };\n  } else if (format.startsWith(\"vorbis\")) {\n    return {\n      ffmpegFormat: \"webm\",\n      mime: 'audio/webm; codecs=\"vorbis\"'\n    };\n  } else if (format.startsWith(\"aac\")) {\n    return {\n      ffmpegFormat: \"mp4\",\n      mime: 'audio/mp4; codecs=\"mp4a.40.2\"' // AAC-LC\n    };\n  } else if (format.startsWith(\"opus\")) {\n    return {\n      ffmpegFormat: \"webm\",\n      mime: 'audio/webm; codecs=\"opus\"'\n    };\n  }\n  throw new Error(\"Unsupported ffmpeg format description: \" + format);\n}\n\nexport class FFmpeg {\n  static defaultArgs = [\n    \"ffmpeg\",\n    \"-hide_banner\", // Hide copyright notice, build options and library versions\n    \"-nostdin\", // Non-interactive mode\n  ];\n\n  static streamRegex = /\\s*Stream #(?<id>\\d+:\\d+)\\(?(?<lang>.*?)\\)?: (?<type>\\w+): (?<formatDescription>.*)/;\n  static durationRegex = /Duration: (\\d+?):(\\d{2}):(.+?),/;\n\n  ffmpegCore: any;\n  private ffmpegMain: any;\n  private ffmpegLogObservable: Observable<string>;\n  private inputMetadata: MediaMetadata;\n  private outputDir = \"/output\";\n  private ffmpegState = FFmpegState.Uninitialized;\n  buf = new Uint8Array();\n\n  constructor() {\n\n  }\n\n  private assertState(expected: FFmpegState) {\n    if (this.ffmpegState != expected) {\n      throw new Error(`Expected state ${expected} but current state is ${this.ffmpegState}`);\n    }\n  }\n\n  isLoaded(): boolean {\n    return !(this.ffmpegState == FFmpegState.Uninitialized);\n  }\n\n  async consumeMetadata() {\n\n    const logEntries = await this.runFFmpeg(\"-i\", \"input.mkv\")\n    console.log(logEntries)\n\n    this.inputMetadata = {\n      durationSeconds: undefined,\n      audioStreams: [],\n      videoStreams: [],\n      subtitleTracks: [],\n      attachments: []\n    };\n    for (const line of logEntries) {\n      const durationMatch = line.match(FFmpeg.durationRegex);\n      if (durationMatch) {\n        this.inputMetadata.durationSeconds = parseFloat(durationMatch[3]) + 60 * parseInt(durationMatch[2]) + 60 * 60 * parseInt(durationMatch[1]);\n      }\n\n      const streamMatch = FFmpeg.streamRegex.exec(line);\n      if (streamMatch) {\n        const { id, lang, type, formatDescription } = streamMatch.groups;\n        const stream: Stream = {\n          id,\n          lang,\n          formatDescription\n        };\n        switch (type) {\n          case \"Audio\":\n            this.inputMetadata.audioStreams.push(stream);\n            break;\n          case \"Video\":\n            this.inputMetadata.videoStreams.push(stream);\n            break;\n          case \"Subtitle\":\n            this.inputMetadata.subtitleTracks.push(stream)\n            break;\n          case \"Attachment\":\n            this.inputMetadata.attachments.push(stream)\n            break;\n          default:\n            console.warn(\"Ignoring non-audio/video stream\", type, stream);\n        }\n      }\n    }\n  }\n\n  async reset() {\n    //const FS = this.ffmpegCore.FS;\n    //FS.writeFile(\"input.mkv\", new Uint8Array())\n    this.buf = new Uint8Array()\n  }\n\n  async writeData(data, start) {\n    //const FS = this.ffmpegCore.FS;\n    //let buf = FS.readFile(\"input.mkv\")\n\n    if (start + data.length > this.buf.length) {\n      const newbuf = new Uint8Array(start + data.length)\n      newbuf.set(this.buf)\n      this.buf = newbuf\n    }\n\n    this.buf.set(data, start)\n    return this.buf\n  }\n\n  async getInputData() {\n    return this.buf\n    const FS = this.ffmpegCore.FS;\n    return FS.readFile(\"input.mkv\")\n  }\n\n  async getMetadata(): Promise<MediaMetadata> {\n    return this.inputMetadata;\n  }\n\n  async remuxChunk(seekOffsetSeconds = 0.0, end, videoStreamId: string, audioStreamId: string): Promise<RemuxedChunk> {\n    // TODO: Get video codec and check if supported by browser and mp4 container\n\n    const videoStreams = this.inputMetadata.videoStreams.filter(s => s.id == videoStreamId);\n    // assert(videoStream.length <= 1);\n    if (videoStreams.length == 0) {\n      throw Error(`No video stream found with id ${videoStreamId}`);\n    }\n    const videoStream: Stream = videoStreams[0];\n    const videoStreamContainer = ffmpegFormatToCompatibleContainer(videoStream.formatDescription);\n\n    var audioStream: Stream;\n    var audioStreamContainer: ContainerType;\n    if (audioStreamId != null) {\n      var audioStreams = this.inputMetadata.audioStreams.filter(s => s.id == audioStreamId);\n      // assert(audioStream.length <= 1);\n      if (audioStreams.length == 0) {\n        throw Error(`No audio stream found with id ${audioStreamId}`);\n      }\n      audioStream = audioStreams[0];\n      audioStreamContainer = ffmpegFormatToCompatibleContainer(audioStream.formatDescription);\n    }\n\n    let args = [\n      \"-ss\", seekOffsetSeconds.toString(), // Seek input file\n      ...(typeof end === \"undefined\" || end == seekOffsetSeconds ? [] : [\"-to\", end.toString()]), // Duration of chunk\n      \"-copyts\",\n      \"-i\", \"input.mkv\"\n    ];\n\n    if (videoStreamContainer) {\n      args = args.concat([\n        \"-map\", videoStream.id,\n        \"-f\", videoStreamContainer.ffmpegFormat,\n        \"-vcodec\", \"copy\",\n        // \"-map_chapters\", \"-1\", // Don't copy chapters metadata, which can cause problems with MIME type containing 'text' codec\n        /*\n         * Fragment MP4 files, required for MSE (frag_keyframe, empty_moov)\n         * Avoid 'TFHD base-data-offset not allowed by MSE.' error for Chrome (default_base_moof)\n         \"-movflags\", \"frag_keyframe+empty_moov+default_base_moof\",\n         */\n        \"-movflags\", \"frag_keyframe+delay_moov+default_base_moof\",\n        \"video\"\n      ]);\n    }\n\n    if (audioStreamContainer) {\n      args = args.concat([\n        \"-map\", audioStream.id,\n        \"-strict\", \"-2\", // Experimental flac in mp4 support\n        \"-f\", audioStreamContainer.ffmpegFormat,\n        \"-acodec\", \"copy\",\n        \"-movflags\", \"frag_keyframe+delay_moov+default_base_moof\",\n        \"audio\"\n      ])\n    }\n\n    await this.runFFmpeg(...args);\n    const FS = this.ffmpegCore.FS;\n\n    let videoChunk: RemuxedChunkStream = null;\n    let audioChunk: RemuxedChunkStream = null;\n\n    if (videoStreamContainer) {\n      videoChunk = {\n        data: FS.readFile(\"video\"),\n        mime: videoStreamContainer.mime\n      };\n      FS.unlink(\"video\");\n    }\n\n    if (audioStreamContainer) {\n      audioChunk = {\n        data: FS.readFile(\"audio\"),\n        mime: audioStreamContainer.mime\n      };\n      FS.unlink(\"audio\");\n    }\n\n    return {\n      audioChunk,\n      videoChunk\n    };\n  }\n\n  async runFFmpeg(...args: string[]) {\n    // parse_args based of utils.js of ffmpeg.wasm-core, but modified to handle UTF-8 paths\n    const parse_args = (Core, _args: string[]) => {\n      const _argsPtr = Core._malloc(_args.length * Uint32Array.BYTES_PER_ELEMENT);\n      _args.forEach((s, idx) => {\n        const bufSize = Core.lengthBytesUTF8(s) + 1;\n        const buf = Core._malloc(bufSize);\n        Core.stringToUTF8(s, buf, bufSize);\n        Core.setValue(_argsPtr + (Uint32Array.BYTES_PER_ELEMENT * idx), buf, 'i32');\n      });\n      return [_args.length, _argsPtr];\n    };\n\n    console.log(\"Running ffmpeg\", args)\n    this.ffmpegState = FFmpegState.Busy;\n    const lines = []\n    try {\n      // @ts-ignore\n      this.ffmpegCore = await createFFmpegCore({\n        //mainScriptUrlOrBlob: FFMpegCore,\n        locateFile: (path, prefix) => {\n          if (path.endsWith('ffmpeg-core.wasm')) {\n            return \"/includes/ffmpeg-core.wasm\";\n          }\n          if (path.endsWith('ffmpeg-core.worker.js')) {\n            return FFMpegWorker;\n          }\n          return prefix + path;\n        },\n        printErr: e => {\n          lines.push(e)\n          console.log(e)\n        },\n        print: e => {\n          console.log(e)\n          lines.push(e)\n        }\n      });\n\n      // Get JavaScript function that calls the underlying wasm function\n      this.ffmpegMain = this.ffmpegCore.cwrap(\n        'main',\n        'number', // exit code\n        ['number', 'number'] // argc, argv\n      );\n      this.ffmpegCore.FS.writeFile(\"input.mkv\", this.buf)\n\n      this.ffmpegMain(...parse_args(this.ffmpegCore, FFmpeg.defaultArgs.concat(args)));\n      console.log('end')\n    } catch (e) {\n      if (e.status == 0) {\n        this.ffmpegState = FFmpegState.Idle\n      } else {\n        console.error(\"Exception caught from entrypoint: \", e)\n      }\n    }\n    return lines\n    //this.ffmpegCore._emscripten_proxy_main(...parse_args(this.ffmpegCore, this.defaultArgs.concat(args)));\n  }\n}\n\nexport default FFmpeg;\n","/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case \"GET\" /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case \"SET\" /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case \"APPLY\" /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case \"CONSTRUCT\" /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case \"ENDPOINT\" /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case \"RELEASE\" /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === \"RELEASE\" /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: \"RELEASE\" /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: \"GET\" /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: \"SET\" /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: \"ENDPOINT\" /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"APPLY\" /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"CONSTRUCT\" /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: \"HANDLER\" /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: \"RAW\" /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case \"HANDLER\" /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case \"RAW\" /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import FFmpeg from './ffmpeg';\nimport * as Comlink from 'comlink';\n\nComlink.expose(new FFmpeg());\n"],"names":["root","factory","exports","module","define","amd","a","i","self","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","p","FFmpegState","ffmpegFormatToCompatibleContainer","format","startsWith","ffmpegFormat","mime","Error","importScripts","outputDir","ffmpegState","Uninitialized","buf","Uint8Array","assertState","expected","this","isLoaded","consumeMetadata","runFFmpeg","logEntries","console","log","inputMetadata","durationSeconds","audioStreams","videoStreams","subtitleTracks","attachments","line","durationMatch","match","FFmpeg","durationRegex","parseFloat","parseInt","streamMatch","streamRegex","exec","groups","id","lang","type","formatDescription","stream","push","warn","reset","writeData","data","start","length","newbuf","set","getInputData","getMetadata","remuxChunk","seekOffsetSeconds","end","videoStreamId","audioStreamId","filter","s","videoStream","videoStreamContainer","audioStream","audioStreamContainer","args","toString","concat","FS","ffmpegCore","videoChunk","audioChunk","readFile","unlink","parse_args","Core","_args","_argsPtr","_malloc","Uint32Array","BYTES_PER_ELEMENT","forEach","idx","bufSize","lengthBytesUTF8","stringToUTF8","setValue","Busy","lines","createFFmpegCore","locateFile","path","prefix","endsWith","printErr","e","print","ffmpegMain","cwrap","writeFile","defaultArgs","status","Idle","error","proxyMarker","Symbol","createEndpoint","releaseProxy","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","createProxy","target","value","serialized","isError","message","name","stack","Object","assign","ep","addEventListener","callback","ev","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfers","transferCache","transfer","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","endpoint","constructor","isMessagePort","close","throwIfProxyReleased","isReleased","isProxyReleased","Proxy","get","_target","requestResponseMessage","r","bind","_thisArg","rawArgumentList","last","processArguments","construct","processed","v","arr","Array","prototype","WeakMap","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l"],"sourceRoot":""}